module Oneof exposing (..)

-- DO NOT EDIT
-- AUTOGENERATED BY THE ELM PROTOCOL BUFFER COMPILER
-- https://github.com/tiziano88/elm-protobuf
-- source file: oneof.proto

import Protobuf exposing (..)

import Json.Decode as JD
import Json.Encode as JE


uselessDeclarationToPreventErrorDueToEmptyOutputFile = 42


type alias Foo =
    { firstOneof : Foo_FirstOneof
    , secondOneof : Foo_SecondOneof
    }


fooDecoder : JD.Decoder Foo
fooDecoder =
    JD.lazy <| \_ -> decode Foo
        |> field foo_FirstOneofDecoder
        |> field foo_SecondOneofDecoder


fooEncoder : Foo -> JE.Value
fooEncoder v =
    JE.object <| List.filterMap identity <|
        [ (foo_FirstOneofEncoder v.firstOneof)
        , (foo_SecondOneofEncoder v.secondOneof)
        ]


type Foo_FirstOneof
    = Foo_FirstOneofUnspecified
    | StringField String
    | IntField Int


foo_FirstOneofDecoder : JD.Decoder Foo_FirstOneof
foo_FirstOneofDecoder =
    JD.lazy <| \_ -> JD.oneOf
        [ JD.map StringField (JD.field "stringField" JD.string)
        , JD.map IntField (JD.field "intField" intDecoder)
        , JD.succeed Foo_FirstOneofUnspecified
        ]


foo_FirstOneofEncoder : Foo_FirstOneof -> Maybe ( String, JE.Value )
foo_FirstOneofEncoder v =
    case v of
        Foo_FirstOneofUnspecified ->
            Nothing

        StringField x ->
            Just ( "stringField", JE.string x )

        IntField x ->
            Just ( "intField", JE.int x )


type Foo_SecondOneof
    = Foo_SecondOneofUnspecified
    | BoolField Bool
    | OtherStringField String


foo_SecondOneofDecoder : JD.Decoder Foo_SecondOneof
foo_SecondOneofDecoder =
    JD.lazy <| \_ -> JD.oneOf
        [ JD.map BoolField (JD.field "boolField" JD.bool)
        , JD.map OtherStringField (JD.field "otherStringField" JD.string)
        , JD.succeed Foo_SecondOneofUnspecified
        ]


foo_SecondOneofEncoder : Foo_SecondOneof -> Maybe ( String, JE.Value )
foo_SecondOneofEncoder v =
    case v of
        Foo_SecondOneofUnspecified ->
            Nothing

        BoolField x ->
            Just ( "boolField", JE.bool x )

        OtherStringField x ->
            Just ( "otherStringField", JE.string x )


type alias Foo2 =
    { firstOneof : Foo2_FirstOneof
    }


foo2Decoder : JD.Decoder Foo2
foo2Decoder =
    JD.lazy <| \_ -> decode Foo2
        |> field foo2_FirstOneofDecoder


foo2Encoder : Foo2 -> JE.Value
foo2Encoder v =
    JE.object <| List.filterMap identity <|
        [ (foo2_FirstOneofEncoder v.firstOneof)
        ]


type Foo2_FirstOneof
    = Foo2_FirstOneofUnspecified
    | StringField String
    | IntField Int


foo2_FirstOneofDecoder : JD.Decoder Foo2_FirstOneof
foo2_FirstOneofDecoder =
    JD.lazy <| \_ -> JD.oneOf
        [ JD.map StringField (JD.field "stringField" JD.string)
        , JD.map IntField (JD.field "intField" intDecoder)
        , JD.succeed Foo2_FirstOneofUnspecified
        ]


foo2_FirstOneofEncoder : Foo2_FirstOneof -> Maybe ( String, JE.Value )
foo2_FirstOneofEncoder v =
    case v of
        Foo2_FirstOneofUnspecified ->
            Nothing

        StringField x ->
            Just ( "stringField", JE.string x )

        IntField x ->
            Just ( "intField", JE.int x )
