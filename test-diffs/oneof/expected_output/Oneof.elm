module Oneof exposing (..)

-- DO NOT EDIT
-- AUTOGENERATED BY THE ELM PROTOCOL BUFFER COMPILER
-- https://github.com/tiziano88/elm-protobuf
-- source file: oneof.proto

import Protobuf exposing (..)

import Json.Decode as JD
import Json.Encode as JE


uselessDeclarationToPreventErrorDueToEmptyOutputFile = 42


type alias Foo =
    { firstOneof : FirstOneof
    , secondOneof : SecondOneof
    }


fooDecoder : JD.Decoder Foo
fooDecoder =
    JD.lazy <| \_ -> decode Foo
        |> field firstOneofDecoder
        |> field secondOneofDecoder


fooEncoder : Foo -> JE.Value
fooEncoder v =
    JE.object <| List.filterMap identity <|
        [ (firstOneofEncoder v.firstOneof)
        , (secondOneofEncoder v.secondOneof)
        ]


type Foo_FirstOneof
    = Foo_FirstOneofUnspecified
    | Foo_StringField String
    | Foo_IntField Int


foo_FirstOneofDecoder : JD.Decoder Foo_FirstOneof
foo_FirstOneofDecoder =
    JD.lazy <| \_ -> JD.oneOf
        [ JD.map Foo_StringField (JD.field "stringField" JD.string)
        , JD.map Foo_IntField (JD.field "intField" intDecoder)
        , JD.succeed Foo_FirstOneofUnspecified
        ]


foo_FirstOneofEncoder : Foo_FirstOneof -> Maybe ( String, JE.Value )
foo_FirstOneofEncoder v =
    case v of
        Foo_FirstOneofUnspecified ->
            Nothing

        Foo_StringField x ->
            Just ( "stringField", JE.string x )

        Foo_IntField x ->
            Just ( "intField", JE.int x )


type Foo_SecondOneof
    = Foo_SecondOneofUnspecified
    | Foo_BoolField Bool
    | Foo_OtherStringField String


foo_SecondOneofDecoder : JD.Decoder Foo_SecondOneof
foo_SecondOneofDecoder =
    JD.lazy <| \_ -> JD.oneOf
        [ JD.map Foo_BoolField (JD.field "boolField" JD.bool)
        , JD.map Foo_OtherStringField (JD.field "otherStringField" JD.string)
        , JD.succeed Foo_SecondOneofUnspecified
        ]


foo_SecondOneofEncoder : Foo_SecondOneof -> Maybe ( String, JE.Value )
foo_SecondOneofEncoder v =
    case v of
        Foo_SecondOneofUnspecified ->
            Nothing

        Foo_BoolField x ->
            Just ( "boolField", JE.bool x )

        Foo_OtherStringField x ->
            Just ( "otherStringField", JE.string x )


type alias Foo2 =
    { firstOneof : FirstOneof
    }


foo2Decoder : JD.Decoder Foo2
foo2Decoder =
    JD.lazy <| \_ -> decode Foo2
        |> field firstOneofDecoder


foo2Encoder : Foo2 -> JE.Value
foo2Encoder v =
    JE.object <| List.filterMap identity <|
        [ (firstOneofEncoder v.firstOneof)
        ]


type Foo2_FirstOneof
    = Foo2_FirstOneofUnspecified
    | Foo2_StringField String
    | Foo2_IntField Int


foo2_FirstOneofDecoder : JD.Decoder Foo2_FirstOneof
foo2_FirstOneofDecoder =
    JD.lazy <| \_ -> JD.oneOf
        [ JD.map Foo2_StringField (JD.field "stringField" JD.string)
        , JD.map Foo2_IntField (JD.field "intField" intDecoder)
        , JD.succeed Foo2_FirstOneofUnspecified
        ]


foo2_FirstOneofEncoder : Foo2_FirstOneof -> Maybe ( String, JE.Value )
foo2_FirstOneofEncoder v =
    case v of
        Foo2_FirstOneofUnspecified ->
            Nothing

        Foo2_StringField x ->
            Just ( "stringField", JE.string x )

        Foo2_IntField x ->
            Just ( "intField", JE.int x )
